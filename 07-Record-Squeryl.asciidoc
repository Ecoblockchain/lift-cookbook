[[Squeryl]]
Relational Database Persistence with Record and Squeryl
-------------------------------------------------------

[[ConfiguringSqueryl]]
Configuring Squeryl and Record
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to configure your Lift application to use Squeryl and Record.

Solution
^^^^^^^^

Include the Squeryl-Record dependency in your build, and in `Boot.scala` provide a database connection function to `SquerylRecord.initWithSquerylSession`.

For example, to configure Squeryl with PostgreSQL, modify `build.sbt` to add two dependencies: one for Squeryl-Record and one for the database driver:

[source, scala]
---------------------------------------------------------------
libraryDependencies ++= {
  val liftVersion = "2.5-M4" 
  Seq(
    "net.liftweb" %% "lift-webkit" % liftVersion,
    "net.liftweb" %% "lift-squeryl-record" % liftVersion,
    "postgresql" % "postgresql" % "9.1-901.jdbc4" 
    ...
    )
}
---------------------------------------------------------------

This will give you access to Squeryl version 0.9.5-6.

In `Boot.scala` we define a connection and register it with Squeryl:

[source, scala]
---------------------------------------------------------------
Class.forName("org.postgresql.Driver")

def connection = DriverManager.getConnection(
  "jdbc:postgresql://localhost/mydb", 
  "username", "password")

SquerylRecord.initWithSquerylSession(
  Session.create(connection, new PostgreSqlAdapter) )

---------------------------------------------------------------

All Squeryl queries need to run in the context of a transaction.  One way to provide a transaction is to configure
a transaction around all HTTP requests. This is also configured in `Boot.scala`:

[source, scala]
---------------------------------------------------------------
S.addAround(new LoanWrapper {
  override def apply[T](f: => T): T = inTransaction { f }
})
---------------------------------------------------------------


Discussion
^^^^^^^^^^

You can use any JVM persistence mechanism with Lift. What Lift Record provides is a light interface around persistence with bindings to Lift's CSS transforms, screens and wizards. Squeryl-Record is a concrete implementation to connect Record with Squeryl.  This means you can use standard Record objects, which are effectively your schema, with Squeryl and write queries wich are validated at compile time.

Plugging into Squeryl means initializing Squeryl's session management, which allows us to wrap queries in Squeryl's `transaction` and `inTransaction` functions.  The difference between these two calls is that `inTransaction` will start a new transaction if one doesn't exist, whereas `transaction` always creates a new transaction.  

By ensuring a transaction is available for all HTTP requests via `addAround`, we can write queries in Lift and for the most part not have to establish transactions ourselves unless we want to.  For example, in a REST service we can write:

[source,scala]
------------------------------------------------------------
import net.liftweb.squerylrecord.RecordTypeMode._
MyRecord.createRecord.myField(aValue).save
------------------------------------------------------------

Or, if you prefer the Squery style of inserts:

[source,scala]
------------------------------------------------------------
import net.liftweb.squerylrecord.RecordTypeMode._
myTable.insert( MyRecord.createRecord.myField(aValue) )
------------------------------------------------------------

In this recipe, the `PostgreSqlAdapter` is being used. SQueryl also supports: `OracleAdapter`, `MySQLInnoDBAdapter` and `MySQLAdapter`, `MSSQLServer`, `H2Adapter`, `DB2Adapter` and `DerbyAdapter`.


See Also
^^^^^^^^

The Squeryl _Getting Started Guide_ links to more information about session management and configuration: http://squeryl.org/getting-started.html[http://squeryl.org/getting-started.html].

See <<SquerylJNDI>> for configuring connections via Java Naming and Directory Interface (JNDI).




[[SquerylJNDI]]
Using a JNDI Datasource
~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to use a JNDI data source for your Record+Squeryl Lift
application.

Solution
^^^^^^^^

In `Boot.scala` call `initWithSquerylSession`...

[source,scala]
------------------------------------------------------------
import javax.sql.DataSource
val ds = new InitialContext().
  lookup("java:comp/env/jdbc/mydb").asInstanceOf[DataSource]

SquerylRecord.initWithSquerylSession(
  Session.create(ds.getConnection(), new MySQLAdapter) )
------------------------------------------------------------

...replacing `mydb` with the name given to your database in your JNDI
configuration, and replacing `MySQLAdapter` with the appropriate adapter
for the database you are using.

Discussion
^^^^^^^^^^

The Java Naming and Directory Interface (JNDI) is service provided by
the web container (e.g., Jetty, Tomcat) which allows you to
configure a database connection in the container and then refer the
connection by name in your application. One advantage of this is that
you can avoid including database credentials to your Lift source base.

The configuration of JNDI is different for each container, and may vary
with versions of the container you use. The _See Also_ section includes
links to the documentation pages for popular containers.

Some environments may also require that you to mention the JNDI resource
in your `src/main/webapp/WEB-INF/web.xml` file:

[source,xml]
------------------------------------------
<resource-ref>
 <res-ref-name>jdbc/mydb</res-ref-name>
 <res-type>javax.sql.DataSource</res-type>
 <res-auth>Container</res-auth>
</resource-ref>
------------------------------------------


See Also
^^^^^^^^

Resources for JDNI configuration include:

* An example on the Lift Wiki for Apache and Jetty configuration at:http://www.assembla.com/spaces/liftweb/wiki/Apache_and_Jetty_Configuration[http://www.assembla.com/spaces/liftweb/wiki/Apache_and_Jetty_Configuration].

* The documentation for Jetty gives examples for various databases: http://www.eclipse.org/jetty/documentation/current/jndi-datasource-examples.html[http://www.eclipse.org/jetty/documentation/current/jndi-datasource-examples.html].

* For Tomcat, the JNDI configuration guide is: http://tomcat.apache.org/tomcat-7.0-doc/jndi-resources-howto.html#JDBC_Data_Sources[http://tomcat.apache.org/tomcat-7.0-doc/jndi-resources-howto.html#JDBC_Data_Sources].



Adding validation to a field
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to add validation to a field in your model.

Solution
^^^^^^^^

Override `validations`. For example:

[source,scala]
------------------------------------------------------------------------
val title = new StringField(this, 256) {
  override def validations = valMinLen(1, "Title cannot be blank") _ :: 
    super.validations
}
------------------------------------------------------------------------

In your snippet you can check the validations, for example:

[source,scala]
---------------------------------------------------------
val thing = MyThing.createRecord.title(title)
thing.validate match {
  case Nil =>
    // No validation problems, so code here to save thing
    S.redirectTo("/success")
  case xs => // One or more validation problems! 
    S.error(xs)  
}
---------------------------------------------------------

In your template, you can reference the column to show any error:

[source,html]
-----------------------------------------------------------------------
<p class="lift:Msg?id=title_id&errorClass=error">Msg to appear here</p>
-----------------------------------------------------------------------

Discussion
^^^^^^^^^^

The built-in validations are:

* `valMinLen` -- validate a string is at least a given length, as shown above.
* `valMaxLen` -- validate that a string is not above a given length.
* `valRegex` -- validate a string matches the given pattern.

An example of regular expression validation would be:

[source,scala]
------------------------------------------------------------
import java.util.regex.Pattern

val url = new StringField(this, 1024) {
  override def validations = 
    valRegex( Pattern.compile("^https?://.*"), 
              "URLs should start http:// or https://") _ :: 
    super.validations
}
------------------------------------------------------------

See Also
^^^^^^^^

* Source for https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/BaseField.scala[BaseField.scala] which includes the definition of `StringValidators`.

Implementing custom validation logic
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to provide your own validation logic and apply it to a field in
a record.

Solution
^^^^^^^^

Implement a function from the type of field you want to validate to
`List[FieldError]`. Perhaps we want to ensure that no-one added to the
database can have the same name, so we need to provide a
`String => List[FieldError]` function:

[source,scala]
-------------------------------------------------------------------------
class Person private () extends Record[Person] with KeyedRecord[Person] {

  override def meta = Person

  @Column(name = "id")
  override val idField = new LongField(this)
 
  val name = new StringField(this, 100) {
    override def validations = 
      valUnique("Please change your name") _ :: super.validations
  }
  
  def valUnique(errorMsg: â‡’ String)(name: String): List[FieldError] = 
    Person.byName(name) match {
      case Some(name) => FieldError(this.name, errorMsg) :: Nil
      case _ => Nil
  }

}
-------------------------------------------------------------------------

Discussion
^^^^^^^^^^

By convention validation functions have two argument lists: the first
for the error message; the second to receive the value to validate. This
allows you to easily re-use your validation function on other fields.

The `FieldError` you return needs to know the field it applies to as
well as the message to display. In the example the field is `name`, but
we've used `this.name` to avoid confusion with the `Some(name)` in the
pattern match or the `name` passed as an argument to `valUnique`.

In case you're wondering, the implementation of `Person.byName` might
be:

[source,scala]
---------------------------------------------
def byName(name: String) = 
  from(YourSchema.people)
  (p => where(lower(p.name) === lower(name)) 
  select (l)).headOption
---------------------------------------------

See Also
^^^^^^^^

* Source for https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/BaseField.scala[BaseField.scala] which includes the definition of `StringValidators`.

Modify a field value before it is set
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to modify the value of a field, so the value in your model is
the modified version.

Solution
^^^^^^^^

Override `setFilter`. For example, to remove leading and trailing
whitespace entered by the user:

[source,scala]
-----------------------------------------------------
val title = new StringField(this, 256) {
   override def setFilter = trim _ :: super.setFilter
}
-----------------------------------------------------

Discussion
^^^^^^^^^^

The built-in filters are:

* `crop` -- enforces the field's min and max length by truncation.
* `trim` -- applies `String.trim` to the field value.
* `toUpper` and `toLower` -- change the case of the field value.
* `removeRegExChars` -- removes matching regular expression characters.
* `notNull` -- coverts null values to an empty string.

See Also
^^^^^^^^

* Source for https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/BaseField.scala[BaseField.scala] which includes the definition of the filters.

Put a random value in a column
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You need a column to hold a random value.

Solution
^^^^^^^^

Use `UniqueIdField`:

[source,scala]
--------------------------------------------
val myColumn = new UniqueIdField(this,32) {}
--------------------------------------------

The size value, 32 in this example, controls the number of characters in
the random field.

Discussion
^^^^^^^^^^

The field is a kind of `StringField` and the default value for the field
comes from `StringHelpers.randomString`.

Note the `{}` in the example: this is required as `UniqueIdField` is an
abstract class.

See Also
^^^^^^^^

* Source for https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/StringHelpers.scala[StringHelpers].

Automatic created and updated timestamps for a Squeryl Record
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want created and updated fields on your records and would like them
automatically updated when a row is added or updated.

Solution
^^^^^^^^

Define the following traits:

[source,scala]
--------------------------------------------------------------
trait Created[T <: Created[T]] extends Record[T] {
  self: T =>
  val created: DateTimeField[T] = new DateTimeField(this) { 
    override def defaultValue = Calendar.getInstance
  }
}

trait Updated[T <: Updated[T]] extends Record[T] {
  self: T =>

  val updated = new DateTimeField(this) { 
    override def defaultValue = Calendar.getInstance
  }

  def onUpdate = this.updated(Calendar.getInstance)

}

trait CreatedUpdated[T <: Updated[T] with Created[T]] extends 
  Updated[T] with Created[T] { 
    self: T => 
}
--------------------------------------------------------------

Add to your model, for example:

[source,scala]
----------------------------------------------------------
class YourRecord private () extends Record[YourRecord] 
  with KeyedRecord[Long] with CreatedUpdated[YourRecord] {
    override def meta = YourRecord
    //field entries ...
}
----------------------------------------------------------

Finally, arrange for the `updated` field to be updated:

[source,scala]
-----------------------------------------------
class YourSchema extends Schema {
  ...
  override def callbacks = Seq(       
    beforeUpdate[YourRecord] call {_.onUpdate} 
  ) 
  ... 
-----------------------------------------------

Discussion
^^^^^^^^^^

_This recipe requires Lift 2.5 or later._

Although there is a built in `net.lifetweb.record.LifecycleCallbacks`
trait in which allows you trigger behaviour onUpdate, afterDelete and so
on, it is only for use on individual Fields, rather than Records. As our
goal is to update the `updated` field when any part of the Record
changes, we can't use the `LiftcycleCallbacks` here.

Instead, the `CreatedUpdated` trait simplifies adding an `updated` and
`created` fields to a Record, but we do need to remember to add a hook
into the schema to ensure the `updated` value is changed when a record
is modified. This is why we set the `callbacks` on the Schema.

It should be noted that `onUpdate` is only called on full updates and
not on partial updates with Squeryl. A full update is when the object is
altered and then saved; a partial update is where you attempt to alter
many objects via a query.

If you're interested in other automations for Record, the Squery schema
callbacks also support other triggered behaviours:

* `beforeInsert` and `afterInsert`
* `afterSelect`
* `beforeUpdate` and `afterUpdate`
* `beforeDelete` and `afterDelete`

See Also
^^^^^^^^

* http://squeryl.org/inserts-updates-delete.html[Explanation of full vs
partial update in Squeryl].
* Mailing list discussion
https://groups.google.com/d/msg/liftweb/G4U14pQbZZ4/V24YvhUPvEEJ[regarding
LifecycleCallbacks]. 

Logging SQL
~~~~~~~~~~~

Problem
^^^^^^^

You want to see the SQL being executed by Record with Squeryl.

Solution
^^^^^^^^

Add the following anytime you have a Squeryl season, such as just before
your query:

[source,scala]
---------------------------------------------------------------
org.squeryl.Session.currentSession.setLogger( s => println(s) )
---------------------------------------------------------------

By providing a `String => Unit` function to `setLogger`, Squeryl will
execute that function with the SQL it runs. In this example, we are
simply printing the SQL to the console.

Discussion
^^^^^^^^^^

This recipe is not specific to Lift, and will work wherever you use
Squeryl.

See Also
^^^^^^^^

* Squeryl http://squeryl.org/getting-started.html[getting started] page.
* Squeryl page on http://squeryl.org/miscellaneous.html[logging the
generated SQL]

Model a column with MySQL MEDIUMTEXT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to use MySQL's `MEDIUMTEXT` for a column, but `StringField`
doesn't have this option.

Solution
^^^^^^^^

Use Squeryl's `dbType`:

[source,scala]
------------------------------------------
on(mytable)(t => declare(
  t.mycolumn defineAs dbType("MEDIUMTEXT")
))
------------------------------------------

Discussion
^^^^^^^^^^

You can continue to use `StringField`, but regardless of the size you
pass, the schema will be:

[source,sql]
--------------------------------
create table mytable (
    mycolumn MEDIUMTEXT not null
);
--------------------------------

This recipe is not specific to Lift, and will work wherever you use
Squeryl.

See Also
^^^^^^^^

* Squeryl http://squeryl.org/schema-definition.html[schema defintion]
page.
* https://groups.google.com/forum/?fromgroups#!topic/liftweb/TXbDGdX54LQ[MySQL,
Squeryl and MEDIUMTEXT with Record] mailing list discussion.






MySQL Unicode Charset Encoding
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

Some characters stored in your MySQL database are appearing as `???`.

Solution
^^^^^^^^

Ensure:

* `Boot.scala` includes: `LiftRules.early.append(_.setCharacterEncoding("UTF-8"))`
* Your JDBC connections URL includes `?useUnicode=true&characterEncoding=UTF-8`
* Your MySQL database has been created using a UTF-8 character set.

See Also
^^^^^^^^

* https://groups.google.com/forum/?fromgroups#!topic/liftweb/DL9AFyU5y2k[EMail thread on the Lift mailing list]
* https://github.com/d6y/mysql-lift-charset-test[MySQL UTF-8 test Lift app] - although it uses SBT 0.7 so is rather out of date.
* http://dev.mysql.com/doc/refman/5.6/en/connector-j-reference-configuration-properties.html[MySQL JDBC COnfiguration reference]




