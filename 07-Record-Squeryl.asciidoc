[[Squeryl]]
Relational Database Persistence with Record and Squeryl
-------------------------------------------------------

Squeryl is an object-relational mapping tool.  It converts Scala classes into tables, rows and columns in a relational database, and provides a way to write SQL-like queries that are type-checked by the Scala compiler. The Lift Squeryl Record module integrates Squeryl with Record, meaning your Lift application and use Squeryl to store and fetch data while making use of the features of record, such as data validation.

Much of the code in this chapter can be found at: https://github.com/LiftCookbook/cookbook_squeryl[https://github.com/LiftCookbook/cookbook_squeryl].

[[ConfiguringSqueryl]]
Configuring Squeryl and Record
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to configure your Lift application to use Squeryl and Record.

Solution
^^^^^^^^

Include the Squeryl-Record dependency in your build, and in `Boot.scala` provide a database connection function to `SquerylRecord.initWithSquerylSession`.

For example, to configure Squeryl with PostgreSQL, modify `build.sbt` to add two dependencies: one for Squeryl-Record and one for the database driver:

[source, scala]
---------------------------------------------------------------
libraryDependencies ++= {
  val liftVersion = "2.5-M4"
  Seq(
    "net.liftweb" %% "lift-webkit" % liftVersion,
    "net.liftweb" %% "lift-squeryl-record" % liftVersion,
    "postgresql" % "postgresql" % "9.1-901.jdbc4"
    ...
    )
}
---------------------------------------------------------------

This will give you access to Squeryl version 0.9.5-6.

In `Boot.scala` we define a connection and register it with Squeryl:

[source, scala]
---------------------------------------------------------------
Class.forName("org.postgresql.Driver")

def connection = DriverManager.getConnection(
  "jdbc:postgresql://localhost/mydb",
  "username", "password")

SquerylRecord.initWithSquerylSession(
  Session.create(connection, new PostgreSqlAdapter) )

---------------------------------------------------------------

All Squeryl queries need to run in the context of a transaction.  One way to provide a transaction is to configure
a transaction around all HTTP requests. This is also configured in `Boot.scala`:

[source, scala]
---------------------------------------------------------------
S.addAround(new LoanWrapper {
  override def apply[T](f: => T): T = inTransaction { f }
})
---------------------------------------------------------------


Discussion
^^^^^^^^^^

You can use any JVM persistence mechanism with Lift. What Lift Record provides is a light interface around persistence with bindings to Lift's CSS transforms, screens and wizards. Squeryl-Record is a concrete implementation to connect Record with Squeryl.  This means you can use standard Record objects, which are effectively your schema, with Squeryl and write queries which are validated at compile time.

Plugging into Squeryl means initializing Squeryl's session management, which allows us to wrap queries in Squeryl's `transaction` and `inTransaction` functions.  The difference between these two calls is that `inTransaction` will start a new transaction if one doesn't exist, whereas `transaction` always creates a new transaction.

By ensuring a transaction is available for all HTTP requests via `addAround`, we can write queries in Lift and for the most part not have to establish transactions ourselves unless we want to.  For example:

[source,scala]
------------------------------------------------------------
import net.liftweb.squerylrecord.RecordTypeMode._
val r = myTable.insert(MyRecord.createRecord.myField(aValue))
------------------------------------------------------------

In this recipe, the `PostgreSqlAdapter` is being used. SQueryl also supports: `OracleAdapter`, `MySQLInnoDBAdapter` and `MySQLAdapter`, `MSSQLServer`, `H2Adapter`, `DB2Adapter` and `DerbyAdapter`.


See Also
^^^^^^^^

The Squeryl _Getting Started Guide_ links to more information about session management and configuration: http://squeryl.org/getting-started.html[http://squeryl.org/getting-started.html].

See <<SquerylJNDI>> for configuring connections via Java Naming and Directory Interface (JNDI).



[[SquerylJNDI]]
Using a JNDI Datasource
~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to use a JNDI data source for your Record+Squeryl Lift
application.

Solution
^^^^^^^^

In `Boot.scala` call `initWithSquerylSession`...

[source,scala]
------------------------------------------------------------
import javax.sql.DataSource
val ds = new InitialContext().
  lookup("java:comp/env/jdbc/mydb").asInstanceOf[DataSource]

SquerylRecord.initWithSquerylSession(
  Session.create(ds.getConnection(), new MySQLAdapter) )
------------------------------------------------------------

...replacing `mydb` with the name given to your database in your JNDI
configuration, and replacing `MySQLAdapter` with the appropriate adapter
for the database you are using.

Discussion
^^^^^^^^^^

The Java Naming and Directory Interface (JNDI) is service provided by
the web container (e.g., Jetty, Tomcat) which allows you to
configure a database connection in the container and then refer the
connection by name in your application. One advantage of this is that
you can avoid including database credentials to your Lift source base.

The configuration of JNDI is different for each container, and may vary
with versions of the container you use. The _See Also_ section includes
links to the documentation pages for popular containers.

Some environments may also require that you to mention the JNDI resource
in your `src/main/webapp/WEB-INF/web.xml` file:

[source,xml]
------------------------------------------
<resource-ref>
 <res-ref-name>jdbc/mydb</res-ref-name>
 <res-type>javax.sql.DataSource</res-type>
 <res-auth>Container</res-auth>
</resource-ref>
------------------------------------------


See Also
^^^^^^^^

Resources for JDNI configuration include:

* An example on the Lift Wiki for Apache and Jetty configuration at:http://www.assembla.com/spaces/liftweb/wiki/Apache_and_Jetty_Configuration[http://www.assembla.com/spaces/liftweb/wiki/Apache_and_Jetty_Configuration].

* The documentation for Jetty gives examples for various databases: http://www.eclipse.org/jetty/documentation/current/jndi-datasource-examples.html[http://www.eclipse.org/jetty/documentation/current/jndi-datasource-examples.html].

* For Tomcat, the JNDI configuration guide is: http://tomcat.apache.org/tomcat-7.0-doc/jndi-resources-howto.html#JDBC_Data_Sources[http://tomcat.apache.org/tomcat-7.0-doc/jndi-resources-howto.html#JDBC_Data_Sources].


[[SquerylyOneToMany]]
One-to-Many Relationship
~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to model a one-to-many relationship, such as a satellite belonging to a single planet, but a planet possibly having many satellites.

Solution
^^^^^^^^

Use Squeryl's `oneToManyRelation` in your schema, and on your Lift model include a reference from the satellite to the planet.

The objective is to model the relationship as shown in <<SquerylPlanetOneToManyFigure>>.

[[SquerylPlanetOneToManyFigure]]
.One planet may have many setellites, but a satellite has one planet.
image::images/planets.png[width=640]

In code:

[source, scala]
-----------------------------------------------------------
package code.model

import org.squeryl.Schema
import net.liftweb.record.{MetaRecord, Record}
import net.liftweb.squerylrecord.KeyedRecord
import net.liftweb.record.field.{StringField, LongField}
import net.liftweb.squerylrecord.RecordTypeMode._

object MySchema extends Schema {

  val planets = table[Planet]
  val satellites = table[Satellite]

  val planetToSatellites = oneToManyRelation(planets, satellites).
    via((p,s) => p.id === s.planetId)

  on(satellites) { s =>
    declare(s.planetId defineAs indexed("planet_idx"))
  }

  class Planet extends Record[Planet] with KeyedRecord[Long] {
    override def meta = Planet
    override val idField = new LongField(this)
    val name = new StringField(this, 256)
    lazy val satellites = MySchema.planetToSatellites.left(this)
  }

  object Planet extends Planet with MetaRecord[Planet]

  class Satellite extends Record[Satellite] with KeyedRecord[Long] {
     override def meta = Satellite
     override val idField = new LongField(this)
     val name = new StringField(this, 256)
     val planetId = new LongField(this)
     lazy val planet = MySchema.planetToSatellites.right(this)
  }

  object Satellite extends Satellite with MetaRecord[Satellite]

}
-----------------------------------------------------------

This schema defines the two tables based on the Record classes, and establishes a one-to-many relation based one (`via`) the `planetId` in the Satellite table.  This allows Squeryl to constrain the `planetId` to reference an existing record in the `Planet` table with a foreign key.

This can be seen in the schema generated by Squeryl:

[source, sql]
-----------------------------------------------------------
-- table declarations :
create table Planet (
    name varchar(256) not null,
    idField bigint not null primary key auto_increment
  );
create table Satellite (
    name varchar(256) not null,
    idField bigint not null primary key auto_increment,
    planetId bigint not null
  );
-- indexes on Satellite
create index planet_idx on Satellite (planetId);
-- foreign key constraints :
alter table Satellite add constraint SatelliteFK1 foreign key (planetId)
  references Planet(idField);
-----------------------------------------------------------

An index called `planet_idx` is declared on the `planetId` field to improve query performance during joins.

Finally we make use of the `planetToSatellites.left` and `right` methods to establish lookup queries.  We can demonstrate their use by inserting example data and running the queries:

[source, scala]
-----------------------------------------------------------
inTransaction {

  code.model.MySchema.create
  org.squeryl.Session.currentSession.setLogger( s => println(s) )

  import code.model.MySchema._

  val earth = planets.insert(Planet.createRecord.name("Earth"))
  val mars = planets.insert(Planet.createRecord.name("Mars"))

  // `.save` as a short-hand for `satellite.insert` when we don't need
  // to immediately reference the record (`save` returns `unit`).
  Satellite.createRecord.name("The Moon").planetId(earth.idField.is).save
  Satellite.createRecord.name("Phobos").planetId(mars.idField.is).save

  val deimos = satellites.insert(
    Satellite.createRecord.name("Deimos").planetId(mars.idField.is) )

  println("Deimos orbits: "+deimos.planet.single.name.is)
  println("Moons of Mars are: "+mars.satellites.map(_.name.is))

}
-----------------------------------------------------------

Running this code produce the output:

-----------------------------------------------------------
Deimos orbits: Mars
Moons of Mars are: List(Phobos, Deimos)
-----------------------------------------------------------


Discussion
~~~~~~~~~~

The `planetToSatellites.left` method is not a simple collection of `Satellite` objects.  It's a Squeryl `Query[Satellite]`, meaning you can treat it like any other kind of `Queryable[Satellite]`.  For example we could ask for those satellites of a planet that are alphabetically after "E", which for Mars would match "Phobos":

[source, scala]
-----------------------------------------------------------
mars.satellites.where(s => s.name gt "E").map(_.name)
-----------------------------------------------------------

The `left` method result is also a `OneToMany[Satellite]` which adds the following methods:

* `assign` -- adds a new relationship, but does not update the database
* `associate` -- which is like `assign` but does update the database
* `deleteAll` -- to remove the relationships.

The `assign` call gives the satellite the relationship to the planet. In code:

[source, scala]
-----------------------------------------------------------
val express = Satellite.createRecord.name("Mars Express")
mars.satellites.assign(express)
express.save
-----------------------------------------------------------

The next time we query `mars.satellites` we'd find the Mars Express orbiter.  A call to `associate` would go one step further for us, making Squeryl insert or update the satellite automatically:

[source, scala]
-----------------------------------------------------------
val express = Satellite.createRecord.name("Mars Express")
mars.satellites.associate(express)
-----------------------------------------------------------

The third method, `deleteAll` does what it sounds like it should do: it would execute the following and return the number of rows removed:

[source, sql]
-----------------------------------------------------------
delete from Satellite
-----------------------------------------------------------

The right side of the one-to-many also has additional methods added by `ManyToOne[Planet]` of `assign` and `delete`.  Be aware that to delete the "one" side of a many-to-one, anything assigned to record will need to have been deleted already to avoid a database constraint error that would arise from, for example, leaving satellites referencing non-existent planets.

There is a variation of `left` and `right` that's worth knowing about.  As `left` and `right` are queries, it means each time you use them you'll be sending a new query to the database.  Squeryl refer to these forms as stateless relations.

The stateful versions of `left` and `right` look like this:

[source, scala]
-----------------------------------------------------------
class Planet extends Record[Planet] with KeyedRecord[Long] {
 ...
 lazy val satellites : StatefulOneToMany[Satellite] =
   MySchema.planetToSatellites.leftStateful(this)
}

class Satellite extends Record[Satellite] with KeyedRecord[Long] {
  ...
  lazy val planet : StatefulManyToOne[Planet] =
    MySchema.planetToSatellites.rightStateful(this)
}
-----------------------------------------------------------

This change means the results of `mars.satellites` will be cached. Subsequent calls on that instance of a `Planet` won't trigger a round trip to the database. You can still `associate` new records or `deleteAll` records which will work as you expect, but if a relationship is added or changed elsewhere you'll need to call `refresh` on the relation to see the change.

Which version should you use? That will depend on your application, but you can use both in the same record if you need to.


See Also
~~~~~~~~

Squeryl relations, and the stateful version, are documented at http://squeryl.org/relations.html[http://squeryl.org/relations.html] and http://squeryl.org/stateful-relations.html[http://squeryl.org/stateful-relations.html].


[[FieldValidation]]
Adding Validation to a Field
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to add validation to a field in your model, so that users are informed of missing fields or fields that aren't acceptable to your application.

Solution
^^^^^^^^

Override `validations`. For example:

[source,scala]
------------------------------------------------------------------------
val title = new StringField(this, 256) {
  override def validations = valMinLen(1, "Title cannot be blank") _ ::
    super.validations
}
------------------------------------------------------------------------

In your snippet you can check the validations:

[source,scala]
---------------------------------------------------------
val thing = MyThing.createRecord.title(title)
thing.validate match {
  case Nil =>
    // No validation problems
    S.redirectTo("/success")
  case xs => // One or more validation problems!
    S.error(xs)
}
---------------------------------------------------------

In your template, you can reference the column to show any error:

[source,html]
-----------------------------------------------------------------------
<p class="lift:Msg?id=title_id&errorClass=error">Msg to appear here</p>
-----------------------------------------------------------------------

Discussion
^^^^^^^^^^

The built-in validations are:

* `valMinLen` -- validate a string is at least a given length, as shown above.
* `valMaxLen` -- validate that a string is not above a given length.
* `valRegex` -- validate a string matches the given pattern.

An example of regular expression validation would be:

[source,scala]
------------------------------------------------------------
import java.util.regex.Pattern

val url = new StringField(this, 1024) {
  override def validations =
    valRegex( Pattern.compile("^https?://.*"),
              "URLs should start http:// or https://") _ ::
    super.validations
}
------------------------------------------------------------

See Also
^^^^^^^^

The `BaseField.scala` class in the Lift source code contains the definition of the built-in `StringValidators`. Find the source at: https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/BaseField.scala[https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/BaseField.scala].



[[CustomValidation]]
Implementing Custom Validation Logic
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to provide your own validation logic and apply it to a field in
a record.

Solution
^^^^^^^^

Implement a function from the type of field you want to validate to
`List[FieldError]`.

As an example, consider a database of people, where we want to ensure that no-one added to the
database can have the same name. For this we need to provide a
`String => List[FieldError]` function:

[source,scala]
-------------------------------------------------------------------------
class Person private () extends Record[Person] with KeyedRecord[Person] {

  override def meta = Person

  @Column(name = "id")
  override val idField = new LongField(this)

  val name = new StringField(this, 100) {
    override def validations =
      valUnique("Please change your name :-)") _ :: super.validations
  }

  def valUnique(errorMsg: ⇒ String)(name: String): List[FieldError] =
    Person.byName(name) match {
      case Some(name) => FieldError(this.name, errorMsg) :: Nil
      case _ => Nil
  }

}
-------------------------------------------------------------------------

Discussion
^^^^^^^^^^

By convention validation functions have two argument lists: the first
for the error message; the second to receive the value to validate. This
allows you to easily re-use your validation function on other fields.

The `FieldError` you return needs to know the field it applies to as
well as the message to display. In the example the field is `name`, but
we've used `this.name` to avoid confusion with the `Some(name)` in the
pattern match or the `name` passed as an argument to `valUnique`.

In case you're wondering, the implementation of `Person.byName` might
be:

[source,scala]
---------------------------------------------
def byName(name: String) =
  from(YourSchema.people)
  (p => where(lower(p.name) === lower(name))
  select (l)).headOption
---------------------------------------------

See Also
^^^^^^^^

<<FieldValidation>> discusses field validation and the built-in validations.



Modify a field value before it is set
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to modify the value of a field, so the value in your model is
the modified version.

Solution
^^^^^^^^

Override `setFilter`. For example, to remove leading and trailing
whitespace entered by the user:

[source,scala]
-----------------------------------------------------
val title = new StringField(this, 256) {
   override def setFilter = trim _ :: super.setFilter
}
-----------------------------------------------------

Discussion
^^^^^^^^^^

The built-in filters are:

* `crop` -- enforces the field's min and max length by truncation.
* `trim` -- applies `String.trim` to the field value.
* `toUpper` and `toLower` -- change the case of the field value.
* `removeRegExChars` -- removes matching regular expression characters.
* `notNull` -- coverts null values to an empty string.

See Also
^^^^^^^^

* Source for https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/BaseField.scala[BaseField.scala] which includes the definition of the filters.

Put a random value in a column
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You need a column to hold a random value.

Solution
^^^^^^^^

Use `UniqueIdField`:

[source,scala]
--------------------------------------------
val myColumn = new UniqueIdField(this,32) {}
--------------------------------------------

The size value, 32 in this example, controls the number of characters in
the random field.

Discussion
^^^^^^^^^^

The field is a kind of `StringField` and the default value for the field
comes from `StringHelpers.randomString`.

Note the `{}` in the example: this is required as `UniqueIdField` is an
abstract class.

See Also
^^^^^^^^

* Source for https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/StringHelpers.scala[StringHelpers].

Automatic created and updated timestamps for a Squeryl Record
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want created and updated fields on your records and would like them
automatically updated when a row is added or updated.

Solution
^^^^^^^^

Define the following traits:

[source,scala]
--------------------------------------------------------------
trait Created[T <: Created[T]] extends Record[T] {
  self: T =>
  val created: DateTimeField[T] = new DateTimeField(this) {
    override def defaultValue = Calendar.getInstance
  }
}

trait Updated[T <: Updated[T]] extends Record[T] {
  self: T =>

  val updated = new DateTimeField(this) {
    override def defaultValue = Calendar.getInstance
  }

  def onUpdate = this.updated(Calendar.getInstance)

}

trait CreatedUpdated[T <: Updated[T] with Created[T]] extends
  Updated[T] with Created[T] {
    self: T =>
}
--------------------------------------------------------------

Add to your model, for example:

[source,scala]
----------------------------------------------------------
class YourRecord private () extends Record[YourRecord]
  with KeyedRecord[Long] with CreatedUpdated[YourRecord] {
    override def meta = YourRecord
    //field entries ...
}
----------------------------------------------------------

Finally, arrange for the `updated` field to be updated:

[source,scala]
-----------------------------------------------
class YourSchema extends Schema {
  ...
  override def callbacks = Seq(
    beforeUpdate[YourRecord] call {_.onUpdate}
  )
  ...
-----------------------------------------------

Discussion
^^^^^^^^^^

_This recipe requires Lift 2.5 or later._

Although there is a built in `net.lifetweb.record.LifecycleCallbacks`
trait in which allows you trigger behaviour onUpdate, afterDelete and so
on, it is only for use on individual Fields, rather than Records. As our
goal is to update the `updated` field when any part of the Record
changes, we can't use the `LiftcycleCallbacks` here.

Instead, the `CreatedUpdated` trait simplifies adding an `updated` and
`created` fields to a Record, but we do need to remember to add a hook
into the schema to ensure the `updated` value is changed when a record
is modified. This is why we set the `callbacks` on the Schema.

It should be noted that `onUpdate` is only called on full updates and
not on partial updates with Squeryl. A full update is when the object is
altered and then saved; a partial update is where you attempt to alter
many objects via a query.

If you're interested in other automations for Record, the Squery schema
callbacks also support other triggered behaviours:

* `beforeInsert` and `afterInsert`
* `afterSelect`
* `beforeUpdate` and `afterUpdate`
* `beforeDelete` and `afterDelete`

See Also
^^^^^^^^

* http://squeryl.org/inserts-updates-delete.html[Explanation of full vs
partial update in Squeryl].
* Mailing list discussion
https://groups.google.com/d/msg/liftweb/G4U14pQbZZ4/V24YvhUPvEEJ[regarding
LifecycleCallbacks].

Logging SQL
~~~~~~~~~~~

Problem
^^^^^^^

You want to see the SQL being executed by Record with Squeryl.

Solution
^^^^^^^^

Add the following anytime you have a Squeryl season, such as just before
your query:

[source,scala]
---------------------------------------------------------------
org.squeryl.Session.currentSession.setLogger( s => println(s) )
---------------------------------------------------------------

By providing a `String => Unit` function to `setLogger`, Squeryl will
execute that function with the SQL it runs. In this example, we are
simply printing the SQL to the console.

Discussion
^^^^^^^^^^

This recipe is not specific to Lift, and will work wherever you use
Squeryl.

See Also
^^^^^^^^

* Squeryl http://squeryl.org/getting-started.html[getting started] page.
* Squeryl page on http://squeryl.org/miscellaneous.html[logging the
generated SQL]

Model a column with MySQL MEDIUMTEXT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to use MySQL's `MEDIUMTEXT` for a column, but `StringField`
doesn't have this option.

Solution
^^^^^^^^

Use Squeryl's `dbType`:

[source,scala]
------------------------------------------
on(mytable)(t => declare(
  t.mycolumn defineAs dbType("MEDIUMTEXT")
))
------------------------------------------

Discussion
^^^^^^^^^^

You can continue to use `StringField`, but regardless of the size you
pass, the schema will be:

[source,sql]
--------------------------------
create table mytable (
    mycolumn MEDIUMTEXT not null
);
--------------------------------

This recipe is not specific to Lift, and will work wherever you use
Squeryl.

See Also
^^^^^^^^

* Squeryl http://squeryl.org/schema-definition.html[schema defintion]
page.
* https://groups.google.com/forum/?fromgroups#!topic/liftweb/TXbDGdX54LQ[MySQL,
Squeryl and MEDIUMTEXT with Record] mailing list discussion.






MySQL Unicode Charset Encoding
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

Some characters stored in your MySQL database are appearing as `???`.

Solution
^^^^^^^^

Ensure:

* `Boot.scala` includes: `LiftRules.early.append(_.setCharacterEncoding("UTF-8"))`
* Your JDBC connections URL includes `?useUnicode=true&characterEncoding=UTF-8`
* Your MySQL database has been created using a UTF-8 character set.

See Also
^^^^^^^^

* https://groups.google.com/forum/?fromgroups#!topic/liftweb/DL9AFyU5y2k[EMail thread on the Lift mailing list]
* https://github.com/d6y/mysql-lift-charset-test[MySQL UTF-8 test Lift app] - although it uses SBT 0.7 so is rather out of date.
* http://dev.mysql.com/doc/refman/5.6/en/connector-j-reference-configuration-properties.html[MySQL JDBC COnfiguration reference]




