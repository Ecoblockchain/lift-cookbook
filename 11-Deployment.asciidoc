[[deployment]]
Production Deployment
---------------------

Deploying to CloudBees
~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You have an account with the CloudBees PaaS hosting environment, and you
want to deploy your Lift application there.

Solution
^^^^^^^^

Use the SBT `package` command to produce a WAR file that can be deployed
to CloudBees, and then use the CloudBees SDK to configure and deploy your
application.

From within the CloudBees "Grand Central" console, create a new application under your account. In what follows we'll assume your account is called _myaccount_ and your application is called _myapp_.

For the best performance you will want to ensure the Lift run mode is set to
"production". Do this from the CloudBees SDK command line:

[source, bash]
---------------------------------------------------------
$ bees config:set -a myaccount/myapp run.mode=production
---------------------------------------------------------

This will set the run mode to production for your CloudBees applications
identified as "myaccount/myapp". Omitting the `-a` will set it for your
whole CloudBees account.

CloudBees will remember this setting, so you only need to do it once.

You can then deploy:

[source, bash]
---------------------------------------------------------------------
$ sbt package
...
[info] Packaging /Users/richard/myapp/target/scala-2.9.1/myapp.war...
...
$ bees -a app:deploy ./target/scala-2.9.1/myapp.war
---------------------------------------------------------------------

This will send your WAR file to CloudBees and deploy it.  You'll see the location (URL) of your application output from the bees `app:deploy` command when it completes.


Discussion
^^^^^^^^^^

If you are deploying an application to multiple CloudBees
instances, be aware that by default CloudBees will round robin requests
to each instance. If you use any of Lift's state features you'll want to
enable session affinity (sticky sessions):

[source, bash]
----------------------------------------------------------------
$ bees app:update -a myaccount/myapp stickySession=true
----------------------------------------------------------------

If you are using comet, it'll work fine, but the CloudBees default is to enable
_request buffering_. This allows CloudBees to do smart things, such as re-routing 
requests in a cluster if one machine does not respond. A
consequence of request buffering is that long-polling comet requests will timeout more
often. To turn this feature off, run the following:

[source, bash]
----------------------------------------------------------------
$ bees app:update -a myaccount/myapp disableProxyBuffering=true
----------------------------------------------------------------

As with the run mode setting, CloudBees will remember these settings, so you 
only need to set them once.

RDBMS Configuration
+++++++++++++++++++

If you are using a SQL database in your application, you'll want to 
configure `src/main/webapp/WEB-INF/cloudbees-web.xml`. For
example:

[source, xml]
--------------------------------------------------------------------------
<?xml version="1.0"?>
<cloudbees-web-app xmlns="http://www.cloudbees.com/xml/webapp/1">

<appid>myaccount/myapp</appid>

<resource name="jdbc/mydb" auth="Container" type="javax.sql.DataSource">  
  <param name="username" value="dbuser" />
  <param name="password" value="dbpassword" />
  <param name="url" value="jdbc:cloudbees://mydb" />

  <!-- For these connections settings, see: 
   http://commons.apache.org/dbcp/configuration.html 
  -->
  <param name="maxActive" value="10" />
  <param name="maxIdle" value="2" />
  <param name="maxWait" value="15000" />
  <param name="removeAbandoned" value="true" />
  <param name="removeAbandonedTimeout" value="300" />
  <param name="logAbandoned" value="true" />

  <!-- Avoid idle timeouts -->
  <param name="validationQuery" value="SELECT 1" />
  <param name="testOnBorrow" value="true" />
 
 </resource>

</cloudbees-web-app>
--------------------------------------------------------------------------

The above is a JNDI database configuration, defining a connection to a
CloudBees database called "mydb". This will be used by Lift if the JNDI
name is referenced in `Boot.scala`:

[source, scala]
------------------------------------------------------------
DefaultConnectionIdentifier.jndiName = "jdbc/mydb"
    
if (!DB.jndiJdbcConnAvailable_?) {
  // set up alternative local database connection here      
}
------------------------------------------------------------

Because the JDNI setting is only defined in `cloudbees-web.xml` it will
only be available in a CloudBees environment. This means you can develop
against a different database locally, and use your CloudBees database
when deploying.

Host IP and Port Number
+++++++++++++++++++++++

Generally you don't need to know about your deployed instance's public host name and port number. Requests to your application URL are routed to the specific instance by CloudBees. However there are situations, especially when you have multiple instances, where you do need to find this out. For example, if you want to receive messages from Amazon's Simple Notification Service (SNS), then each instance will need to give a direct URL to SNS when the application boots.  

To get the public hostname, you need to make a HTTP request to `http://instance-data/latest/meta-data/public-hostname`, as documented at https://developer.cloudbees.com/bin/view/Main/Finding+out+app+port+and+hostname[https://developer.cloudbees.com/bin/view/Main/Finding+out+app+port+and+hostname].  For example:

[source, scala]
------------------------------------------------------------
import io.Source

val beesPublicHostname : Box[String] = tryo {
  Source.fromURL("http://instance-data/latest/meta-data/public-hostname").
    getLines().toStream.head
}
------------------------------------------------------------

This will return a `Full` hostname on the CloudBees environment, but when running locally will fail and return a `Failure`. For example:

[source, scala]
------------------------------------------------------------
Failure(instance-data,Full(java.net.UnknownHostException: instance-data),Empty)
------------------------------------------------------------

The port number can be read from the JVM system property of `sun.java.command`. This is the command that started your application and it includes the port number. An example would be:

------------------------------------------------------------
net.stax.appserver.bootstrap.Bootstrap -dir /var/genapp/apps/d414b3f4/staxcat 
  -port 8783 -config /var/genapp/apps/d414b3f4/appserver.xml
------------------------------------------------------------

We can pick out the port number with a regular expression:

[source, scala]
------------------------------------------------------------
val beesPort : Box[String] = for {
  command <- Box !! System.getProperty("sun.java.command")
  port <- """.*-port (\d+) .*""".r findFirstMatchIn command
} yield port group 1
------------------------------------------------------------

Running locally this will return a `Empty` box, but on CloudBees you'll see a `Full[String]` port number.

You might put these two values together as follows:

[source, scala]
------------------------------------------------------------
import java.net.InetAddress

val hostAndPort : String =
  (beesPublicHostname openOr InetAddress.getLocalHost.getHostAddress) +
  ":" + (beesPort openOr "8080")
------------------------------------------------------------

Running locally `hostAndPort` might be `192.168.1.60:8080` and running on CloudBees it would be something like `ec2-204-236-222-252.compute-1.amazonaws.com:8520`. 

ClickStarts
+++++++++++

ClickStart Applications are templates to quickly get an application, and automated build, up and running at CloudBees. The Lift ClickStart creates a private Git source repository at CloudBees which contains a Lift 2.4 application, provisions a MySQL database, creates a Maven-based Jenkins build, and deploys the application.  All you need to do is provide a name for the application (without whitespace).

To access the Git source repository created for you, you'll need to upload a SSH public key. You can do this in the "My Keys" section of your account settings on the CloudBees web site.

The build that's created for you will automatically build and deploy your application to CloudBees when you push changes to your Git repository.

If all of that's a good match to the technologies and services you want to use, ClickStart is a great way to deploy your application. Alternatively, it gives you a starting point from which you can modify elements; or you could fork the CloudBees Lift template and create your own from https://github.com/CloudBees-community/lift_template[https://github.com/CloudBees-community/lift_template].


See Also
^^^^^^^^

The CloudBees SDK provides command line tools for configuring and controlling applications. It can be found at https://wiki.cloudbees.com/bin/view/RUN/BeesSDK[https://wiki.cloudbees.com/bin/view/RUN/BeesSDK].

The CloudBees developer portal (https://developer.cloudbees.com[https://developer.cloudbees.com])contains a "Resources" section which provides details of the CloudBees services.

A plugin is available to automate deployments from SBT. The plugin and the excellent 
instructions for installing and configuring it can be found at https://github.com/timperrett/sbt-cloudbees-plugin[https://github.com/timperrett/sbt-cloudbees-plugin].



[[Beanstalk]]
Deploying to Amazon Elastic Beanstalk
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to run your Lift application on Amazon Web Services (AWS) Elastic Beanstalk.


Solution
^^^^^^^^

Create a new Tomcat 7 _environment_, use SBT to package your Lift application as a WAR file, and then deploy the application to your environment.

To create a new environment, visit the AWS console, navigate to Elastic Beanstalk and select "Apache Tomcat 7" as your environment. This will create and launch a default Beanstalk application. This will take a few minutes, but eventually report "Successfully running version Sample Application". You'll be shown the URL of the application (something like `http://default-environment-nsdmixm7ja.elasticbeanstalk.com`) and visiting the URL you're given will show the running default Amazon application.

Prepare your WAR file by running:

[source, bash]
-------------------------
$ sbt package
-------------------------

This will write a WAR file into the `target` folder.  To deploy this WAR file from the AWS Beanstalk web console (see <<ConsoleImage>>), select the "Versions" tab under the "Elastic Beanstalk Application Details" and click the "Upload new version" button. You'll be given a dialog where you give a version label and use the "Choose file" button to select the WAR file you just built.  You can either upload and deploy in one step, or upload first and then select the version in the console and hit the "Deploy" button.

The Beanstalk console will show "Environment updating..." and after some minutes it'll report "Successfully running".  Your Lift application is now deployed and running on Beanstalk.

A final step is to enable Lift's production run mode. From the environment in the AWS Beanstalk web console, follow the "Edit Configuration" link. A dialog will appear, and under the "Container" tab add `-Drun.mode=production` to the "JVM Command Line Options" and hit "Apply Changes" to redeploy your application.

[[ConsoleImage]]
.AWS Console, with Elastic Beanstalk service selected.
image::images/beanstalkconsole.png[AWS Console, with Elastic Beanstalk service selected]

Discussion
^^^^^^^^^^

Elastic Beanstalk provides a pre-built stack of software and infrastructure, in this case: Linux, Tomcat 7, a 64 bit "t1.micro" EC2 instance, load balancing, and an S3 bucket. That's the _environment_ and it has reasonable default settings.  Beanstalk also provides an easy way to deploy your Lift application.  As we've seen in this recipe, you upload an application (WAR file) to Beanstalk and deploy it to the environment.

As with many cloud providers keep in mind that you want to avoid local file storage. The reason for this is to allow instances to be terminated or restarted without data loss. With your Beanstalk application you do have a file system and you can write to it, but it is lost if the image is restarted. You can get persistent local file storage, for example using Amazon Elastic Block Storage, but you're fighting against the nature of the platform.

Log files are written to the local file system. To access them, from the AWS console, navigate to your environment, into the "Logs" tab and hit the "Snapshot" button. This will take a copy of the logs and store them in an S3 bucket, and give you a link to the file contents.  This is a single file showing the content of variety of log files, and `catalina.out` will be the one showing any output from your Lift application.  If you want to try to keep these log files around, you can configure the environment to rotate the logs to S3 every hour from the "Container" tab under "Edit Configuration".

The Lift application WAR files are stored in the same S3 bucket that the logs are stored in. From the AWS console, you'll find it under the S3 page listed with a name like `elasticbeanstalk-us-east-1-5989673916964`. You'll note that the AWS uploads makes your WAR filename unique by adding a prefix to each filename. If you need to be able to tell the difference between these files in S3, one good approach is to is to bump the `version` value in your `build.sbt` file.  This version number is included in the WAR filename.

Multiple Instances
++++++++++++++++++

Beanstalks enables _auto scaling_ by default. That is, it launches a single instance of your Lift application, but if the load increases above a threshold, up to four instances may be running.

If you're making use of Lift's state features, you'll need to enable sticky sessions from the "Load Balancer" tab of the environment configuration. It's a check box named "Enable Session Stickiness"--it's easy to miss, but that tab does scroll to show more options if you don't see it first time.


Working with a Database
++++++++++++++++++++++++

There's nothing unusual you have to do to use Lift and a database from Beanstalk. However, Beanstalk does try to make it easy for you to work with Amazon's Relational Database Service (RDS).  Either when creating your Beanstalk environment, or from the configuration options later, you can add an RDS instance, which cab be an Oracle, SQL-Server or MySQL database. 

The MySQL option will create a MySQL 5.5 InnoDB database. The database will be accessible from Beanstalk, but not from elsewhere on the Internet. To change that, modify the security groups for the RDS instance from the AWS web console.  For example, you might permit access from your IP address.

When your application launches with an associated RDS instance, the JVM system properties include settings for the database name, host, port, user and password.  You could pull them together like this in `Boot.scala`:

[source,scala]
-------------------------------------------
Class.forName("com.mysql.jdbc.Driver")

val connection = for {
  host <- Box !! System.getProperty("RDS_HOSTNAME")
  port <- Box !! System.getProperty("RDS_PORT")
  db   <- Box !! System.getProperty("RDS_DB_NAME")
  user <- Box !! System.getProperty("RDS_USERNAME")
  pass <- Box !! System.getProperty("RDS_PASSWORD")
} yield DriverManager.getConnection(
    "jdbc:mysql://%s:%s/%s" format (host,port,db),
    user, pass)
-------------------------------------------

That would give you a `Box[Connection]` which, if `Full`, you could use in a `SquerylRecord.initWithSquerylSession` call for example (see <<Squeryl>>).  

Alternatively you might want to guarantee a connection by supplying defaults for all the values with something like this:

[source,scala]
-------------------------------------------
Class.forName("com.mysql.jdbc.Driver")

val connection = {
  val host = System.getProperty("RDS_HOSTNAME", "localhost")
  val port = System.getProperty("RDS_PORT", "3306")
  val db = System.getProperty("RDS_DB_NAME", "db")
  val user = System.getProperty("RDS_USERNAME", "sa")
  val pass = System.getProperty("RDS_PASSWORD", "")

  DriverManager.getConnection(
    "jdbc:mysql://%s:%s/%s" format (host,port,db),
    user, pass)
}
-------------------------------------------


See Also
^^^^^^^^

Amazon provide a walk-through with screen shots, showing how to create a Beanstalk application.  It's at: http://docs.amazonwebservices.com/elasticbeanstalk/latest/dg/GettingStarted.Walkthrough.html[http://docs.amazonwebservices.com/elasticbeanstalk/latest/dg/GettingStarted.Walkthrough.html]. 

_Elastic Beanstalk_, by van Villet _et al_ (2011, O'Reilly Media, Inc) goes into the details of the Beanstalk infrastructure, how to work with Eclipse, enabling continuous integration, and how to hack the instance, for example to use NGINX as a front-end to Beanstalk.

The Amazon documentation for "Configuring Databases with AWS Elastic Beanstalk" describes the RDS settings in more detail: http://docs.amazonwebservices.com/elasticbeanstalk/latest/dg/using-features.managing.db.html[http://docs.amazonwebservices.com/elasticbeanstalk/latest/dg/using-features.managing.db.html].



