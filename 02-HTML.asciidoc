HTML
----

Testing and Debugging CSS Selectors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to explore or debug CSS selectors interactively.

Solution
^^^^^^^^

Use the Scala REPL to run your CSS selector. From withing SBT use the `console` command to get into the REPL. Here's an example were we test out a CSS selector which applies a href to a link:

----
> console             
[info] Starting scala interpreter...
[info] 
Welcome to Scala version 2.9.1.final 
Type in expressions to have them evaluated.
Type :help for more information.

scala> import net.liftweb.util.Helpers._ 
import net.liftweb.util.Helpers._

scala> val in = <a>click me</a>
in: scala.xml.Elem = <a>click me</a>

scala> val f = "a [href]" #> "http://example.org"
f: net.liftweb.util.CssSel = 
  (Full(a [href]), Full(ElemSelector(a,Full(AttrSubNode(href)))))

scala> f(in)
res0: scala.xml.NodeSeq = 
  NodeSeq(<a href="http://example.org">click me</a>)
----

Discussion
^^^^^^^^^^

CSS selector transforms are one of the distinguishing features of Lift. They succinctly describe a node in your template (left-hand side) and give a replcement (right-hand side). They do take a little while to get use to, so being able to test them at the Scala REPL is useful.

It may help to know that prior to CSS selectors Lift snippets were typically defined in terms
of a function that took a `NodeSeq` and returned a `NodeSeq`, often via the `bind` method.  When Lift processes such a template it knows what the input `NodeSeq` is, so it's natural to supply a function that returns a `NodeSeq`.  You won't see that usage so often any more, but the principle is the same. 

The CSS selector functionality in Lift gives you a `CssSel` function
which is `NodeSeq => NodeSeq`. We exploit this in the above example by constructing an input
`NodeSeq` (called `in`), then creating a CSS function (called `f`).  Because we know that `CssSel`
is defined as a `NodeSeq => NodeSeq` the natural way to execute the selector is to supply
the `in` as a parameter, and this gives us the answer, `res0`.

See Also
^^^^^^^^

The syntax for selectors is best described in _Simply Lift_ at http://simply.liftweb.net/index-7.10.html#toc-Section-7.10[http://simply.liftweb.net/index-7.10.html#toc-Section-7.10].

Section 6.1.2 of _Lift in Action_ also describes selectors and gives examples.


Sequencing CSS Selector Operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want your CSS selector binding to apply to the results of earlier
binding expressions.

Solution
^^^^^^^^

Use `andThen` rather than `&` to compose your selector expressions. 

For example, suppose we want to replace `<div id="foo"/>` with
`<div id="bar">bar content</div>` but for some reason we needed to
generate the `bar` div as a separate step in the selector expression:

----
sbt> console
[info] Starting scala interpreter...
[info] 
Welcome to Scala version 2.9.1.final (Java 1.7.0_05).
Type in expressions to have them evaluated.
Type :help for more information.

scala> import net.liftweb.util.Helpers._
import net.liftweb.util.Helpers._

scala> def render = "#foo" #> <div id="bar"/> andThen "#bar *" #> "bar content"
render: scala.xml.NodeSeq => scala.xml.NodeSeq

scala> render(<div id="foo"/>)
res0: scala.xml.NodeSeq = NodeSeq(<div id="bar">bar content</div>)
----

Discussion
^^^^^^^^^^

When using `&` think of the CSS selectors as always applying to the
original template, no matter what other expressions you are combining.
This is because `&` is aggregating the selectors together before applying them; whereas `andThen` is 
a method of all Scala functions that composes two functions together, with the fist being
called before the second.   

Compare the example above if we change the `andThen` with
`&`:

----
scala> def render = "#foo" #> <div id="bar" /> & "#bar *" #> "bar content"
render: net.liftweb.util.CssSel

scala> render(<div id="foo"/>)
res1: scala.xml.NodeSeq = NodeSeq(<div id="bar"></div>)           
----

The second expression will not match as it is applied to the original
input of `<div id="foo"/>`. There's no `id="bar"` in there to match on,
so this means in the second expression adds
nothing to the `render`.

See Also
^^^^^^^^

This topic is from the Lift mailing list, and you can see the original context there:
https://groups.google.com/forum/?fromgroups#!topic/liftweb/fz3Pmlhzhfg[https://groups.google.com/forum/?fromgroups#!topic/liftweb/fz3Pmlhzhfg].



Setting Meta Tag Contents
~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to set the content of an HTML meta tag using Lift.

Solution
^^^^^^^^

Use the `@` CSS binding name selector. For example, given:

----
<meta name="keywords" content="words, here, please" />
----

The following snippet code will update the value of the contents
attribute:

----
"@keywords [content]" #> "words, we, really, want" 
----

Discussion
^^^^^^^^^^

The `@` selector selects all elements with the given name. It's useful in this case to change `<meta name="keyword">` tag, but you may also see it used with elsewhere, for example with HTML forms to select input fields, such as `<input name="address">`.  

The `[content]` part is an example of a _replacement rule_ that can follow a selector. That's to say, it's not specific to the `@` selector and can be used with other selectors.  In this example it adds or replaces the value of the attribute called "content".

There are two other replacement rules useful for manipulating attributes: removing attributes and appending to attributes:

* `[content!]` to remove an attribute with a matching value, which in our example would be `"@keywords [content!]" #> "words, here, please"`.
* `[content+]` to append to the value, such as `"@keywords [content+]" #> ", more"`.

Although not directly relevant to `meta` tags, you should be aware of there is one convenient special case for appending to an attribute. If the attribute is `class`, a space is added together with your class value. As a demonstration of that, here's an example of appending a class called "funky" to a `div`:

---------------------------------------------------------------------
scala> def render = "div [class+]" #> "funky"
render: net.liftweb.util.CssSel

scala> render(<div class="wrapper"/>)
res0: scala.xml.NodeSeq = NodeSeq(<div class="wrapper funky"></div>)
---------------------------------------------------------------------


See Also
^^^^^^^^

The syntax for selectors is best described in _Simply Lift_ at http://simply.liftweb.net/index-7.10.html[http://simply.liftweb.net/index-7.10.html].


Setting the Page Title
~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to set the `<title>` of the page from a Lift snippet.

Solution
^^^^^^^^

Select all the elements of the `title` element and replace them with the
text you want:

----
"title *" #> "I am different"
----

Assuming you have a `<title>` tag in your template, the above will
result in:

----
<title>I am different</title>
----

Discussion
^^^^^^^^^^

It is also possible to set the page title from the contents of `SiteMap`,
meaning the title used will be the title you've assigned to the page in
the site map:

----
<title class="lift:Menu.title"></title>
----

The `lift:Menu.title` code appends to any existing text in the title.
This means the following will have the phrase "Site Title - " in the
title followed by the page title:

----
<title class="lift:Menu.title">Site Title - </title>
----

If you need more control, you can of course bind on title using a
regular snippet. This example uses a custom snippet to put the site
title after the page title:

----
<title class="lift:MyTitle"></title>

object MyTitle {
  def render = <title><lift:Menu.title /> - Site Title</title>
}
----

See Also
^^^^^^^^

*  _Simply Lift_ chapter 7: http://simply.liftweb.net/index-7.10.html[http://simply.liftweb.net/index-7.10.html].

* The Wiki page for SiteMap: http://www.assembla.com/spaces/liftweb/wiki/SiteMap[http://www.assembla.com/spaces/liftweb/wiki/SiteMap].

* The "dynamic titles on sitemap" mailing list discussion offers further options for computing page titles:
http://groups.google.com/group/liftweb/browse_thread/thread/e19bd2dda2b3159d[http://groups.google.com/group/liftweb/browse_thread/thread/e19bd2dda2b3159d].


Including HTML5 Shiv
~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to include HTML5 Shiv (a.k.a. HTML5 Shim) so you can use HTML5
elements with legacy IE browsers.

Solution
^^^^^^^^

Put the markup in a snippet and include the snippet in your page or
template.

----
package code.snippet

import scala.xml.Unparsed

object Html5Shiv {        
  def render = Unparsed("""<!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js">
  </script><![endif]-->""")
}
----

Reference the snippet in the `<head>` of your
`templates-hidden/default.html`, e.g.,:

----
<script class="lift:Html5Shiv"></script>
----

Discussion
^^^^^^^^^^

The HTML5 parser used by Lift does not carry comments from the source
through to the rendered page. If you just tried to paste the html5shim markup into 
your template you'd find it missing from the rendered page.

We deal with this by generating unparsed markup from a snippet. If you're looking at 
`Unparsed` and worried, your instincts are correct.  Normally Lift would cause the
markup to be escaped, but in this case we really do want
unparsed XML content (the comment tag) included in the output. 

See Also
^^^^^^^^

If you're doing a lot of IE conditional includes, take a look at the mailing list
suggestion from Antonio Salazar Cardozo for using a IE confitional comment snippet: https://groups.google.com/d/msg/liftweb/kLzcJwfIqHQ/K91MdtoNz0MJ[https://groups.google.com/d/msg/liftweb/kLzcJwfIqHQ/K91MdtoNz0MJ].

The html5shim project can be found at: http://code.google.com/p/html5shim/[http://code.google.com/p/html5shim/].


Returning Snippet Markup Unchanged
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want a snippet to return the original markup associated with the
snippet invocation.

Solution
^^^^^^^^

Use the `PassThru` transform. For
example, suppose you have a snippet which performs a transforms when some
condition is met, but if the condition is not met, you want the snippet
return the original markup.

Starting with the original markup...

----
<div class="myclass"> 
  <p>Nothing to worry about</p> 
</div>
----

...we could leave it alone or change it with this snippet:

----
def render = if (someCondition)
    ".myclass *" #> <p>The condition happened</p>
  else
    PassThru
----

Discussion
^^^^^^^^^^

`PassThru` is a `NodeSeq => NodeSeq` function that returns the input it
is given (an identity function).  It's defined as:

-----
object PassThru extends Function1[NodeSeq, NodeSeq] {
  def apply(in: NodeSeq): NodeSeq = in
}
-----

The pattern of converting one `NodeSeq` to another is simple, but also powerful enough to get you out of most situations as you can always arbitrarily re-write the `NodeSeq`.


See Also
^^^^^^^^

* The _How
to return the original markup associated with snippet invocation?_ mailing list discussion: https://groups.google.com/d/msg/liftweb/A69tyIBBSdg/mUGO6_qUFqwJ[https://groups.google.com/d/msg/liftweb/A69tyIBBSdg/mUGO6_qUFqwJ]

* Take a look at the source for `PassThru`, which is at https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/CssSel.scala[https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/CssSel.scala], to see how this and other similar functions are defined. 


Snippet Not Found when using HTML5
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You're using Lift with the HTML5 parser and one of your snippets,
perhaps `<lift:HelloWorld.howdy />`, is rendering with a "Class Not
Found" error.

Solution
^^^^^^^^

Switch to the designer-friendly snippet invocation mechanism. E.g.,

----
<div class="lift:HellowWorld.howdy">...</div>
----

Discussion
^^^^^^^^^^

The HTML5 parser and the traditional Lift XHTML parser have different
behaviours. In particular the HTML5 parser converts elements and attribute names to lower
case when looking up snippets. This means Lift would take `<lift:HelloWorld.howdy />` and look for a class called "helloworld" rather than "HelloWorld", which would be the cause of the "Class Not Found Error".

Switching to the designer-friendly mechnism is the solution here, and you gain validating HTML as a bonus.

In this text we use the HTML5 parser, which is set in `Boot.scala`:

-----
// Use HTML5 for rendering
LiftRules.htmlProperties.default.set( (r: Req) => 
  new Html5Properties(r.userAgent) )
----


See Also
^^^^^^^^

The key differences between the XHTML and HTML5 parser are outlined on the mailing list at https://groups.google.com/d/msg/liftweb/H-xe1uRLW1c/B60UH8P54VAJ[https://groups.google.com/d/msg/liftweb/H-xe1uRLW1c/B60UH8P54VAJ].



Avoiding CSS and JavaScript Caching
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You've modified CSS or JavaScript in your application, but web browsers
have cached your resources and are using the older versions. You'd like
to avoid this browser caching.

Solution
^^^^^^^^

Add the `lift:with-resource-id` class attribute to script or link tags:

----
<script class="lift:with-resource-id" src="/myscript.js" 
 type="text/javascript"></script>
----

The addition of this class will cause Lift to append a "resource id" to
your `src` (or `href`), and as this resource id changes each time Lift
starts, it defeats browser caching.

The resultant HTML might be:

----
<script src="/myscript.js?F619732897824GUCAAN=_" 
  type="text/javascript" ></script>
----

Discussion
^^^^^^^^^^

The randome value that is appended to the resource is computed when your Lift application boots.  This means it should be stable between releases of your application.

If you need some other behaviour from `with-resource-id` you can assign
a new function of type `String => String` to
`LiftRules.attachResourceId`. The default implementation, shown above,
takes the resource name ("/myscript.js" in the example) and returns the
resource name with an id appended. 

You can also wrap a number of tags inside a
`<lift:with-resource-id>...<lift:with-resource-id>` block. However,
avoid doing this in the `<head>` of your page as the HTML5 parser will
move the tags to be outside of the head section.

Note that some proxies may choose not to cache resources with query
parameters at all. If that impacts you, it's possible to code a custom resource id method
to move the random resouce ID out of the query parameter and into the path.

Here's one approach to doing this. Rather than generate JavaScript and CSS links that look like `/myscript.js?F61973`, we will generate `/cache/F61973/myscript.js`. We then will need to tell Lift to take requests 
that look like this new format, and render the correct content for the request.  This all happens in `Boot.scala`:

-----------
// The random number we're using to avoid caching
val resourceId = Helpers.nextFuncName

// Prefix lift:with-resource-id links with "/cache/{resouceId}"
LiftRules.attachResourceId = (path: String) => {
  "/cache/" + resourceId + path
}

// The resource suffix we're caching: ".js" or ".css" 
object CacheableExt {
  def unapply(s: String): Option[String] = s match {
    case "js" | "css" => Some(s)
    case _ => None
  }
}

// Remove the cache/{resourceId} from the request if there is one
LiftRules.statelessRewrite.prepend( NamedPF("BrowserCacheAssist") {
  case RewriteRequest( 
    ParsePath("cache" :: id :: file, CacheableExt(suffix), _,_), _, _) => 
    RewriteResponse(file.init ++ List(file.last+"."+suffix), Map[String,String]())
})
-----------

The `statelessRewrite` is a little long, but it's doing quite a lot.  First, it's matching only 
request that start with "cache", followed by some value, followed by a filename, where the suffix
of the file matches the `CacheableExt`.  If it does, we reconstruct the path without the caching part.


See Also
^^^^^^^^

The source for `LiftRules` shows the default implementation of `attachResourceId`: https://github.com/lift/framework/blob/master/web/webkit/src/main/scala/net/liftweb/http/LiftRules.scala[https://github.com/lift/framework/blob/master/web/webkit/src/main/scala/net/liftweb/http/LiftRules.scala].

Google's _Optimize caching_ notes are a good source of information about browser behaviour: https://developers.google.com/speed/docs/best-practices/caching[https://developers.google.com/speed/docs/best-practices/caching].


Adding to the Head of a Page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You use a template for layout, but on one specific page you need to add
something to the `<head>` section.

Solution
^^^^^^^^

Use the `lift:head` snippet or CSS class so Lift knows to merge the
contents with the `<head>` of your page. For example, suppose you have
the following contents in `templates-hidden/default.html`:

----
<html lang="en" xmlns:lift="http://liftweb.net/"> 
  <head> 
    <meta charset="utf-8"></meta> 
    <title class="lift:Menu.title">App: </title>
    <script id="jquery" src="/classpath/jquery.js" 
      type="text/javascript"></script>
    <script id="json" src="/classpath/json.js" 
      type="text/javascript"></script>
 </head>
 <body>
     <div id="content">The main content will get bound here</div>
 </body>
</html>
----

Also suppose you have `index.html` on which you want to include `my.css`
just for that page. Do so by including the CSS in the part of the page
that will get processed and mark it for the head with `lift:head`:

-----
<!DOCTYPE html>
<html>
 <head>
   <title>Special</title>
 </head>
 <body class="lift:content_id=main">
  <div id="main" class="lift:surround?with=default;at=content">
   <link class="lift:head" rel="stylesheet" href="/my.css" type='text/css'>
   <h2>Hello</h2>
  </div>
 </body>
</html>
-----

Note that this `index.html` page is validated HTML5, and will produce a
result with the custom CSS inside the `<head>` tag, something like this:

----
<!DOCTYPE html>
<html lang="en">
 <head> 
  <meta charset="utf-8"> 
  <title>App:  Home</title>
  <script type="text/javascript" 
    src="/classpath/jquery.js" id="jquery"></script>
  <script type="text/javascript" 
    src="/classpath/json.js" id="json"></script>
  <link rel="stylesheet" href="/my.css" type="text/css">
 </head>
 <body>
   <div id="main">
     <h2>Hello</h2>
   </div>
  <script type="text/javascript" src="/ajax_request/liftAjax.js"></script>
  <script type="text/javascript"> 
  // <![CDATA[
  var lift_page = "F557573613430HI02U4";
  // ]]>
  </script>
 </body>
</html>
----

Discussion
^^^^^^^^^^

If you find your tags not appearing the the `<head>` section, check that
the HTML in your template and page is valid HTML5.

You can also use `<lift:head>...</lift:head>` to wrap a number of
expressions, and will see `<head_merge>...</head_merge>` used in code
example as an alternative to `<lift:head>`.

You may also see `data-lift="head"` is also used as an alternative to
`class="lift:head"`.

See Also
^^^^^^^^


* Mailing list discussion on a
https://groups.google.com/forum/?fromgroups#!topic/liftweb/rG_pOXdp4Ew[designer
friendly way of head merge.].

* http://validator.w3.org/[W3C HTML validator]. 

Custom 404 page
~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to show a customised "404" (page not found) page.

Solution
^^^^^^^^

In `Boot.scala` add the following:

[source,scala]
----
LiftRules.uriNotFound.prepend(NamedPF("404handler"){
  case (req,failure) => 
    NotFoundAsTemplate(ParsePath(List("404"),"html",false,false))
})
----

The file `src/main/webapp/404.html` will now be served for requests to
unknown resources.

Discussion
^^^^^^^^^^

The `uriNotFound` Lift rule needs to return a `NotFound` in reply to a
`Req` (request) and optional `Failure`. This allows you to customise the
response based on the type of failure or the request that was made.

There are three types of `NotFound`:

* `NotFoundAsTemplate` is useful to invoke the Lift template processing
facilities from a `ParsePath`.
* `NotFoundAsResponse` allows you to return a specific `LiftResponse`.
* `NotFoundAsNode` wrappers a `NodeSeq` for Lift to translate into a 404
response.

In case you're wondering, the two `false` arguments to `ParsePath`
indicates the path we've given isn't absolute, and doesn't end in a
slash.

See Also
^^^^^^^^

* http://www.assembla.com/spaces/liftweb/wiki/Custom_404_-_URI_not_found_page[Lift
Wiki entry for this topic]

Other custom status pages
~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to show a customised page for certain HTTP status codes.

Solution
^^^^^^^^

Use `LiftRules.responseTransformers` to match against the response and
supply an alternative.

For example, suppose we want to provide a customised page for 403
("Forbidden") statuses created in your Lift application. In `Boot.scala`
we could add the following:

[source,scala]
----
LiftRules.responseTransformers.append {
  case r if r.toResponse.code == 403 => RedirectResponse("/403.html")
  case r => r
}
----

The file `src/main/webapp/403.html` will now be served for requests that
generate 403 status codes. Other requests are passed through.

Discussion
^^^^^^^^^^

`LiftRules.responseTransformers` allows you to supply
`LiftResponse => LiftResponse` functions to change a response at the end
of the HTTP processing cycle. This is a very general mechanism: in this
example we are matching on a status code, but we could match on anything
exposed by `LiftResponse`. We've shown a `RedirectResponse` being
returned but there are many different kinds of `LiftResponse` we could
send to the client.

One way to test the above example is to add the following to Boot to
make all requests to `/secret` return a 403:

[source,scala]
----
val Protected = If(() => false, () => ForbiddenResponse("no way"))

val entries = List(
  Menu.i("Home") / "index", 
  Menu.i("secret") / "secret" >> Protected,
  Menu.i("403") / "403" >> Hidden 
  // rest of your site map here...
)
----

See Also
^^^^^^^^

* _The Request/Response Lifecycle_ in
http://exploring.liftweb.net/master/index-9.html#toc-Section-9.2[Exploring
Lift].
* Mailing list discussion of
https://groups.google.com/forum/?fromgroups#!topic/liftweb/9wU0hzQ0wgs%5B1-25%5D[custom
error 403 page].

Links in notices
~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to include a clickable link in your `S.error`, `S.notice` or
`S.warning` messages.

Solution
^^^^^^^^

Include a `NodeSeq` containing a link in your notice:

[source,scala]
----
S.error("checkPrivacyPolicy", 
  <span>See our <a href="/policy">privacy policy</a></span>)
----

You might pair this with the following in your template:

[source,html]
----
<div class="lift:Msg?id=checkPrivacyPolicy"></div>
----

See Also
^^^^^^^^

* http://www.assembla.com/spaces/liftweb/wiki/Lift_Notices_and_Auto_Fadeout[Lift
Notices and Auto Fadeout] wiki page.
* Mailing list question:
https://groups.google.com/forum/?fromgroups#!topic/liftweb/Q6ToHnebOB0[Is
there a way for the display of the S.errror to have a clickable URL in
it?]

Rendering Textile markup
~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to render Textile markup in your web app.

Solution
^^^^^^^^

Install the Lift Textile module in your `build.sbt` file by adding the
following to the list of dependencies:

`scala "net.liftweb" %% "lift-textile" % liftVersion % "compile->default",`
You can then render Textile using `toHtml` method:

[source,scala]
----
scala> import net.liftweb.textile._                   
import net.liftweb.textile._

scala> TextileParser.toHtml("""h1. Hi!              
 | 
 | The module in "Lift":http://www.liftweb.net for turning Textile markup 
 | into HTML is pretty easy to use.
 | 
 | * As you can see
 | * in this example
 |""")
res0: scala.xml.NodeSeq = 
NodeSeq(<h1>Hi!</h1>, 
, <p>The module in <a href="http://www.liftweb.net">Lift</a> for turning 
Textile markup into HTML is pretty easy to use.</p>, 
, <ul><li> As you can see</li>
<li> In this example</li>
</ul>, 
, )
----

Discussion
^^^^^^^^^^

Textile is one of many
http://en.wikipedia.org/wiki/Lightweight_markup_language[lightweight
markup language], but stands out for Lift users as being easy to install
and use.

See Also
^^^^^^^^

* http://redcloth.org/hobix.com/textile/[A Textile Reference].
* http://textile.thresholdstate.com/[An online Textile to HTML tool]
from Threshold State.
* _Lift in Action_, chapter 7 contains a wiki example that uses the
Textile plugin.
*
https://github.com/lift/modules/blob/master/textile/src/main/scala/net/liftweb/textile/TextileParser.scala[Lift
Source code for Textile].
*
https://github.com/lift/modules/blob/master/textile/src/test/scala/net/liftweb/textile/TextileSpec.scala[Lift
tests for the Textile plugin]. 

Access restriction by HTTP header
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You need to control access to a page based on the value of a HTTP
header.

Solution
^^^^^^^^

Use a custom `If` in SiteMap:

[source,scala]
----
val HeaderRequired = If(  
  () => S.request.map(_.header("ALLOWED") == Full("YES")) openOr false,
  "Access not allowed" 
)

// Build SiteMap
val entries = List(
      Menu.i("Restricted") / "restricted" >> HeaderRequired
)
----

In this example `restricted.html` can only be viewed if the request
includes a HTTP header called `ALLOWED` with a value of `Yes`. Any other
request for the page will be redirected with a Lift error notice of
"Access not allowed".

This can be tested from the command line using a tool like cURL:

----
$ curl http://127.0.0.1:8080/restricted.html -H "ALLOWED:YES"
----

Discussion
^^^^^^^^^^

The `If` test ensures the `() => Boolean` function you supply as a first
argument returns `true` before the page it applies to is shown. The
second argument is what Lift does if the test isn't true, and should be
a `() => LiftResponse` function, meaning you can return whatever you
like, including redirects to other pages.

In the example we are making use of a convenient implicit conversation
from a `String` ("Access not allowed") to a redirection that will take
the user to the home page (actually
`LiftRules.siteMapFailRedirectLocation`) with a notice which shows the
string.

See Also
^^^^^^^^

* Mailing list thread on
https://groups.google.com/forum/?fromgroups#!topic/liftweb/CtSGkPbgEVw[testing
a Loc for a HTTP Header Value for Access Control].
* Source for
https://github.com/lift/framework/blob/master/web/webkit/src/main/scala/net/liftweb/sitemap/Loc.scala[Loc.scala]
where `If` and other tests are defined.
* Chapter 7, "SiteMap and access control" in _Lift in Action_.
* http://exploring.liftweb.net/onepage/index.html#toc-Chapter-7[Site map
in _Exploring Lift_].


